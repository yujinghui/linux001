/*
* linux/mm/memory.c
*
* (C) 1991 Linus Torvalds
*/

/*
* demand-loading started 01.12.91 - seems it is high on the list of
* things wanted, and it should be easy to implement. - Linus
*/
/*
* ??????01.12.91 ????? - ?????????????????
* ??????????? - linus
*/

/*
* Ok, demand-loading was easy, shared pages a little bit tricker. Shared
* pages started 02.12.91, seems to work. - Linus.
*
* Tested sharing by executing about 30 /bin/sh: under the old kernel it
* would have taken more than the 6M I have free, but it worked well as
* far as I could see.
*
* Also corrected some "invalidate()"s - I wasn't doing enough of them.
*/
/*
* OK??????????????????????????????????
* 02.12.91 ???????????? - Linus?
*
* ??????30 ?/bin/sh ???????????????????????
* 6M ?????????????????????
*
* ?"invalidate()"???????? - ???????????
*/

#include <signal.h> // ??????????????????????????????

#include <asm/system.h> // ?????????????????/????????????

#include <linux/sched.h> // ???????????????task_struct?????0 ????
// ????????????????????????????
#include <linux/head.h>   // head ??????????????????????????
#include <linux/kernel.h> // ??????????????????????

volatile void do_exit(long code); // ??????????kernel/exit.c?102 ??

//// ????????????????
static inline volatile void
oom(void)
{
  printk("out of memory\n\r");
  do_exit(SIGSEGV); // do_exit()????????????????SIGSEGV(11)
} // ?????????????????????????

// ?????????????
// ????????????CPU ????????????????????????????
// ???????????????????????????????cr3 ?????????
// ??eax = 0?????????
#define invalidate() \
  __asm__("movl %%eax,%%cr3" ::"a"(0))

/* these are not to be changed without changing head.s etc */
/* ??????????????head.s ????????????? */
// linux 0.11 ??????????????16M??????????????????
#define LOW_MEM 0x100000                      // ?????1MB??
#define PAGING_MEMORY (15 * 1024 * 1024)      // ????15MB???????15M?
#define PAGING_PAGES (PAGING_MEMORY >> 12)    // ???????????
#define MAP_NR(addr) (((addr)-LOW_MEM) >> 12) // ????????????
#define USED 100                              // ??????????405 ??

// CODE_SPACE(addr) ((((addr)+0xfff)&~0xfff) < current->start_code + current->end_code)?
// ??????????????????????????252 ??
#define CODE_SPACE(addr) ((((addr) + 4095) & ~4095) < \
                          current->start_code + current->end_code)

static long HIGH_MEMORY = 0; // ???????????????????

// ??1 ????4K ????
#define copy_page(from, to)                                   \
  __asm__("cld ; rep ; movsl" ::"S"(from), "D"(to), "c"(1024) \
          : "cx", "di", "si")

// ???????(1 ????1 ???)????????????????????????????
static unsigned char mem_map[PAGING_PAGES] = {
    0,
};

/*
* Get physical address of first (actually last :-) free page, and mark it
* used. If no free pages left, return 0.
*/
/*
* ????(??????1 ?:-)??????????????????????
* ???0?
*/
//// ?????????????????????0?
// ???%1(ax=0) - 0?%2(LOW_MEM)?%3(cx=PAGING PAGES)?%4(edi=mem_map+PAGING_PAGES-1)?
// ?????%0(ax=??????)?
// ??%4 ???????mem_map[]????????????????????????????
// ????????????PAGING_PAGES?????????????????0?????????
// ???????????????????????????????????????????
// ?put_page()???????????
unsigned long
get_free_page(void)
{
  register unsigned long __res asm("ax");

  __asm__("std ; repne ; scasb\n\t"    // ???????al(0)????????(di)?????
          "jne 1f\n\t"                 // ??????0 ????????????0??
          "movb $1,1(%%edi)\n\t"       // ????????????1?
          "sall $12,%%ecx\n\t"         // ???*4K = ?????????
          "addl %2,%%ecx\n\t"          // ????????????????????????
          "movl %%ecx,%%edx\n\t"       // ???????????edx ????
          "movl $1024,%%ecx\n\t"       // ???ecx ????1024?
          "leal 4092(%%edx),%%edi\n\t" // ?4092+edx ?????edi(??????)?
          "rep ; stosl\n\t"            // ?edi ?????????????????????
          "movl %%edx,%%eax\n"         // ?????????eax??????
          "1:"
          : "=a"(__res)
          : ""(0), "i"(LOW_MEM), "c"(PAGING_PAGES), "D"(mem_map + PAGING_PAGES - 1)
          : "di", "cx",
            "dx");
  return __res; // ??????????????????0??
}

/*
* Free a page of memory at physical address 'addr'. Used by
* 'free_page_tables()'
*/
/*
* ??????'addr'????????????'free_page_tables()'?
*/
//// ??????addr ?????????
// 1MB ??????????????????????????????
void free_page(unsigned long addr)
{
  if (addr < LOW_MEM)
    return;                // ??????addr ???????1MB??????
  if (addr >= HIGH_MEMORY) // ??????addr>=??????????????
    panic("trying to free nonexistent page");
  addr -= LOW_MEM; // ????????????????4KB??????
  addr >>= 12;
  if (mem_map[addr]--)
    return;          // ???????????????0???1 ???
  mem_map[addr] = 0; // ????????????0????????????
  panic("trying to free free page");
}

/*
* This function frees a continuos block of page tables, as needed
* by 'exit()'. As does copy_page_tables(), this handles only 4Mb blocks.
*/
/*
* ???????????????'exit()'???????copy_page_tables()
* ?????????4Mb ?????
*/
//// ?????????????????????????????????????????
// ?????????0 ?????1024 ???4K ???????????????
// ???????0x1000 ??????????????????1024 ????4K ???
// ??????????????4K??????????????4 ????
// ???from - ??????size - ??????
int free_page_tables(unsigned long from, unsigned long size)
{
  unsigned long *pg_table;
  unsigned long *dir, nr;

  if (from & 0x3fffff) // ???????????4M ????
    panic("free_page_tables called with wrong alignment");
  if (!from) // ?????????????????
    panic("Trying to free up swapper memory space");
  // ?????????(4M ??????)?????????
  size = (size + 0x3fffff) >> 22;
  // ???????????????????=from>>22?????4 ????????????
  // ????0 ?????????????=????<<2???(from>>20)???0xffc ??
  // ??????????
  dir = (unsigned long *)((from >> 20) & 0xffc); /* _pg_dir = 0 */
  for (; size-- > 0; dir++)
  {                                                  // size ????????????????
    if (!(1 & *dir))                                 // ????????(P ?=0)?????
      continue;                                      // ?????0(P ?)???????????
    pg_table = (unsigned long *)(0xfffff000 & *dir); // ??????????
    for (nr = 0; nr < 1024; nr++)
    {                    // ?????1024 ????
      if (1 & *pg_table) // ???????(P ?=1)??????????
        free_page(0xfffff000 & *pg_table);
      *pg_table = 0; // ?????????
      pg_table++;    // ?????????
    }
    free_page(0xfffff000 & *dir); // ??????????????????
                                  // ????1M ?????????????
    *dir = 0;                     // ????????????
  }
  invalidate(); // ??????????
  return 0;
}

/*
* Well, here is one of the most complicated functions in mm. It
* copies a range of linerar addresses by copying only the pages.
* Let's hope this is bug-free, 'cause this one I don't want to debug :-)
*
* Note! We don't copy just any chunks of memory - addresses have to
* be divisible by 4Mb (one page-directory entry), as this makes the
* function easier. It's used only by fork anyway.
*
* NOTE 2!! When from==0 we are copying kernel space for the first
* fork(). Then we DONT want to copy a full page-directory entry, as
* that would lead to some serious memory waste - we just copy the
* first 160 pages - 640kB. Even that is more than we need, but it
* doesn't take any more memory - we don't copy-on-write in the low
* 1 Mb-range, so the pages can be shared with the kernel. Thus the
* special case for nr=xxxx.
*/
/*
* ??????????mm ?????????????????????
* ????????????????????????????????
* ??????????
*
* ???????????????? - ?????????4Mb ??????
* ??????????????????????????????????
* ???fork()???fork.c ?56 ???
*
* ??2???from==0 ????????fork()?????????????
* ??????????????????????????????? - ??
* ????160 ??? - ??640kB?????????????????????
* ??????????? - ??1Mb ???????????????????
* ????????????????nr=xxxx ??????nr ??????????
*/
//// ????????????????????????????????????????
//// ?????????????????
// ????????????????????????????????????????????
// ????????????????????????????????????????????
int copy_page_tables(unsigned long from, unsigned long to, long size)
{
  unsigned long *from_page_table;
  unsigned long *to_page_table;
  unsigned long this_page;
  unsigned long *from_dir, *to_dir;
  unsigned long nr;

  // ?????????????4Mb ?????????????????
  if ((from & 0x3fffff) || (to & 0x3fffff))
    panic("copy_page_tables called with wrong alignment");
  // ??????????????(from_dir ?to_dir)????115 ?????
  from_dir = (unsigned long *)((from >> 20) & 0xffc); /* _pg_dir = 0 */
  to_dir = (unsigned long *)((to >> 20) & 0xffc);
  // ????????????????????????
  size = ((unsigned)(size + 0x3fffff)) >> 22;
  // ?????????????????????
  for (; size-- > 0; from_dir++, to_dir++)
  {
    // ????????????????(P=1)????????
    if (1 & *to_dir)
      panic("copy_page_tables: already exist");
    // ?????????????????????????
    if (!(1 & *from_dir))
      continue;
    // ???????????????from_page_table?
    from_page_table = (unsigned long *)(0xfffff000 & *from_dir);
    // ??????????????????0 ??????????????????=-1????
    if (!(to_page_table = (unsigned long *)get_free_page()))
      return -1; /* Out of memory, see freeing */
                 // ??????????7 ????????(Usr, R/W, Present)?
    *to_dir = ((unsigned long)to_page_table) | 7;
    // ???????????????????????????????????160 ??????
    // ??1 ???????1024 ???
    nr = (from == 0) ? 0xA0 : 1024;
    // ???????????????nr ??????
    for (; nr-- > 0; from_page_table++, to_page_table++)
    {
      this_page = *from_page_table; // ????????
      if (!(1 & this_page))         // ??????????????????
        continue;
      // ??????R/W ??(?0)?(??U/S ??0??R/W ????????U/S ?1??R/W ?0?
      // ????????????????????U/S ?R/W ????????????)
      this_page &= ~2;
      *to_page_table = this_page; // ??????????????
                                  // ??????????????1M ????????????????mem_map[]?????
                                  // ????????????????????????????
      if (this_page > LOW_MEM)
      {
        // ?????????????????????????????????????????
        // ?????????????????????????????????????????
        // ?????????????????????
        *from_page_table = this_page; // ?????????
        this_page -= LOW_MEM;
        this_page >>= 12;
        mem_map[this_page]++;
      }
    }
  }
  invalidate(); // ??????????
  return 0;
}

/*
* This function puts a page in memory at the wanted address.
* It returns the physical address of the page gotten, 0 if
* out of memory (either when trying to access page-table or
* page.)
*/
/*
* ????????????????????????????????
* ????(?????????)????0?
*/
//// ????????????????????
// ??????????????????????????????????
unsigned long
put_page(unsigned long page, unsigned long address)
{
  unsigned long tmp, *page_table;

  /* NOTE !!! This uses the fact that _pg_dir=0 */
  /* ??!!!??????????_pg_dir=0 ??? */

  // ???????????LOW_MEM(1Mb)?????????????HIGH_MEMORY???????
  if (page < LOW_MEM || page >= HIGH_MEMORY)
    printk("Trying to put page %p at %p\n", page, address);
  // ???????????????????????????????
  if (mem_map[(page - LOW_MEM) >> 12] != 1)
    printk("mem_map disagrees with %p at %p\n", page, address);
  // ?????????????????????
  page_table = (unsigned long *)((address >> 20) & 0xffc);
  // ????????(P=1)(???????????)???????????????page_table?
  if ((*page_table) & 1)
    page_table = (unsigned long *)(0xfffff000 & *page_table);
  else
  {
    // ????????????????????????????7?User, U/S, R/W?????
    // ????????page_table?
    if (!(tmp = get_free_page()))
      return 0;
    *page_table = tmp | 7;
    page_table = (unsigned long *)tmp;
  }
  // ???????????????????????????????1024 ?(0x3ff)?
  page_table[(address >> 12) & 0x3ff] = page | 7;
  /* no need for invalidate */
  /* ???????????? */
  return page; // ???????
}

//// ???????????????????????????????????
// ???????????
// [ un_wp_page ????????????Un-Write Protected?]
void un_wp_page(unsigned long *table_entry)
{
  unsigned long old_page, new_page;

  old_page = 0xfffff000 & *table_entry; // ????????????
                                        // ?????????????LOW_MEM(1Mb)?????????????????1????
                                        // ???1 ??????????????????????R/W ?????????????
                                        // ??????????
  if (old_page >= LOW_MEM && mem_map[MAP_NR(old_page)] == 1)
  {
    *table_entry |= 2;
    invalidate();
    return;
  }
  // ??????????????????
  if (!(new_page = get_free_page()))
    oom(); // Out of Memory????????
           // ????????????????mem_map[]>1???????????????????
           // ?????1?????????????????????????????(U/S, R/W, P)?
           // ?????????????????????????
  if (old_page >= LOW_MEM)
    mem_map[MAP_NR(old_page)]--;
  *table_entry = new_page | 7;
  invalidate();
  copy_page(old_page, new_page);
}

/*
* This routine handles present pages, when users try to write
* to a shared page. It is done by copying the page to a new address
* and decrementing the shared-page counter for the old page.
*
* If it's in code space we exit with a segment error.
*/
/*
* ????????????????????????????????????
* ??????????????????????????????????
*
* ?????????????????????
*/
//// ??????????C ??????????????page.s ???????
// ??error_code ??CPU ?????address ????????
// ???????????????????
void do_wp_page(unsigned long error_code, unsigned long address)
{
#if 0
/* we cannot do this yet: the estdio library writes to code space */
/* stupid, stupid. I really want the libc.a from GNU */
/* ?????????????estdio ???????????? */
/* ???????????GNU ??libc.a ??*/
  if (CODE_SPACE (address))	// ???????????????????
    do_exit (SIGSEGV);
#endif
  // ?????????????????????????????????
  // ((address>>10) & 0xffc)????????????????????
  // (0xfffff000 &((address>>20) &0xffc))?????????????
  // ??((address>>20) &0xffc)???????????????
  // ??????????????????????????????????
  un_wp_page((unsigned long *)(((address >> 10) & 0xffc) + (0xfffff000 &
                                                            *((unsigned long
                                                                   *)((address >> 20) &
                                                                      0xffc)))));
}

//// ??????
// ??????????????fork.c ?34 ?????
void write_verify(unsigned long address)
{
  unsigned long page;

  // ????????????????????(P)?????(P=0)????
  if (!((page = *((unsigned long *)((address >> 20) & 0xffc))) & 1))
    return;
  // ??????????????????????????????????????????
  page &= 0xfffff000;
  page += ((address >> 10) & 0xffc);
  // ????????(??R/W ????)??????????????????????
  if ((3 & *(unsigned long *)page) == 1) /* non-writeable, present */
    un_wp_page((unsigned long *)page);
  return;
}

//// ????????????????????
// ?get_free_page()???get_free_page()???????????????????????
// ?????????????????????put_page()????????????????
// ??
void get_empty_page(unsigned long address)
{
  unsigned long tmp;

  // ??????????????????????????????????????
  // 279 ???????????????get_free_page()??0 ???????put_page()
  // ????????????????????210 ??
  if (!(tmp = get_free_page()) || !put_page(tmp, address))
  {
    free_page(tmp); /* 0 is ok - ignored */
    oom();
  }
}

/*
* try_to_share() checks the page at address "address" in the task "p",
* to see if it exists, and if it is clean. If so, share it with the current
* task.
*
* NOTE! This assumes we have checked that p != current, and that they
* share the same executable.
*/
/*
* try_to_share()???"p"???????"address"??????????????????
* ?????????????????
*
* ??????????p !=???????????????????
*/
//// ????????????????????
// ??????????????????????????????
// ??1-???0-???
static int
try_to_share(unsigned long address, struct task_struct *p)
{
  unsigned long from;
  unsigned long to;
  unsigned long from_page;
  unsigned long to_page;
  unsigned long phys_addr;

  // ?????????????
  from_page = to_page = ((address >> 20) & 0xffc);
  // ????p ????????????????
  from_page += ((p->start_code >> 20) & 0xffc);
  // ??????????????????????
  to_page += ((current->start_code >> 20) & 0xffc);
  /* is there a page-directory at from? */
  /* ?from ?????????*/
  // *** ?p ?????????
  // ????????????????(P=0)????????????????????from?
  from = *(unsigned long *)from_page;
  if (!(from & 1))
    return 0;
  from &= 0xfffff000;
  // ?????????????????????????phys_addr?
  from_page = from + ((address >> 10) & 0xffc);
  phys_addr = *(unsigned long *)from_page;
  /* is the page clean and present? */
  /* ??????????*/
  // 0x41 ???????Dirty ?Present ?????????????????
  if ((phys_addr & 0x41) != 0x01)
    return 0;
  // ????????phys_addr??????????????????(1M)??????
  phys_addr &= 0xfffff000;
  if (phys_addr >= HIGH_MEMORY || phys_addr < LOW_MEM)
    return 0;
  // *** ????????????
  // ?????????to?????????(P=0)???????????to_page ???????
  to = *(unsigned long *)to_page;
  if (!(to & 1))
    if (to = get_free_page())
      *(unsigned long *)to_page = to | 7;
    else
      oom();
  // ?????????to????????to_page????????????????????
  to &= 0xfffff000;
  to_page = to + ((address >> 10) & 0xffc);
  if (1 & *(unsigned long *)to_page)
    panic("try_to_share: to_page already exists");
  /* share them: write-protect */
  /* ????????????? */
  // ?p ???????????(?R/W=0 ??)??????????????????
  *(unsigned long *)from_page &= ~2;
  *(unsigned long *)to_page = *(unsigned long *)from_page;
  // ??????????
  invalidate();
  // ?????????????????????????????1?
  phys_addr -= LOW_MEM;
  phys_addr >>= 12;
  mem_map[phys_addr]++;
  return 1;
}

/*
* share_page() tries to find a process that could share a page with
* the current one. Address is the address of the wanted page relative
* to the current data space.
*
* We first check if it is at all feasible by checking executable->i_count.
* It should be >1 if there are other tasks sharing this inode.
*/
/*
* share_page()????????????????????????address ?
* ??????????????????
*
* ????????executable->i_count ??????????????????
* ?inode???????1?
*/
//// ????????????????????
// ??1 - ???0 - ???
static int
share_page(unsigned long address)
{
  struct task_struct **p;

  // ?????????????excutable ????????i ?????
  if (!current->executable)
    return 0;
  // ????????(executable->i_count=1)?????
  if (current->executable->i_count < 2)
    return 0;
  // ????????????????????????????????????????????
  for (p = &LAST_TASK; p > &FIRST_TASK; --p)
  {
    if (!*p) // ???????????????
      continue;
    if (current == *p) // ???????????????
      continue;
    if ((*p)->executable != current->executable) // ??executable ???????
      continue;
    if (try_to_share(address, *p)) // ???????
      return 1;
  }
  return 0;
}

//// ???????????????????????page.s ???????
// ??error_code ??CPU ?????address ????????
void do_no_page(unsigned long error_code, unsigned long address)
{
  int nr[4];
  unsigned long tmp;
  unsigned long page;
  int block, i;

  address &= 0xfffff000; // ?????
                         // ??????????????????????????????
  tmp = address - current->start_code;
  // ??????executable ????????????+??????????????????
  // ????????????executable ????i ????????0???????????
  // ???????????????????????????????????????????
  // ???????get_empty_page()?????????????????????????
  // start_code ?????????end_data ???????????linux ?????????
  // ?????????????
  if (!current->executable || tmp >= current->end_data)
  {
    get_empty_page(address);
    return;
  }
  // ???????????????
  if (share_page(tmp))
    return;
  // ???????????????????????????
  if (!(page = get_free_page()))
    oom();
  /* remember that 1 block is used for header */
  /* ???????????1 ???? */
  // ??????????????BLOCK_SIZE = 1024 ???????????4 ?????
  block = 1 + tmp / BLOCK_SIZE;
  // ??i ??????????????????????
  for (i = 0; i < 4; block++, i++)
    nr[i] = bmap(current->executable, block);
  // ????????????4 ????????????page ??
  bread_page(page, current->executable->i_dev, nr);
  // ?????????????????????????end_data ?????????????
  // ??????????????
  i = tmp + 4096 - current->end_data;
  tmp = page + 4096;
  while (i-- > 0)
  {
    tmp--;
    *(char *)tmp = 0;
  }
  // ??????????????????????????????????????????
  if (put_page(page, address))
    return;
  free_page(page);
  oom();
}

//// ????????
// ???start_mem - ????????????????????RAMDISK ?????????
// end_mem - ???????????
// ????linux ?????????16Mb ??????16Mb ??????????????
// 0 - 1Mb ??????????????0-640Kb??
void mem_init(long start_mem, long end_mem)
{
  int i;

  HIGH_MEMORY = end_mem;             // ????????
  for (i = 0; i < PAGING_PAGES; i++) // ???????????(USED=100)???
    mem_map[i] = USED;               // ???????????USED?
  i = MAP_NR(start_mem);             // ????????????????
  end_mem -= start_mem;              // ???????????????
  end_mem >>= 12;                    // ?????????????????
  while (end_mem-- > 0)              // ?????????????????????
    mem_map[i++] = 0;
}

// ?????????????
void calc_mem(void)
{
  int i, j, k, free = 0;
  long *pg_tbl;

  // ??????????mem_map[]????????????
  for (i = 0; i < PAGING_PAGES; i++)
    if (!mem_map[i])
      free++;
  printk("%d pages free (of %d)\n\r", free, PAGING_PAGES);
  // ??????????0?1 ??????????????????????????????
  for (i = 2; i < 1024; i++)
  {
    if (1 & pg_dir[i])
    {
      pg_tbl = (long *)(0xfffff000 & pg_dir[i]);
      10.5 page.s ???or(j = k = 0; j < 1024; j++) if (pg_tbl[j] & 1)
          k++;
      printk("Pg-dir[%d] uses %d pages\n", i, k);
    }
  }
}
